# modules/01_k8s_observer.sh
#
# Contains functions related to ServiceAccount and RBAC configuration.

# Global variables
SA_NAME="asm-k8s-account"
SECRET_NAME="$${SA_NAME}-legacy-token"
NAMESPACE="default"

fn_configure_rbac_for_service_account() {
    echo "Applying RBAC for Service Account: $${SA_NAME}"

    # 1. Create the ServiceAccount
    kubectl create serviceaccount "$${SA_NAME}" --namespace "$${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -

    # 2. Create the ClusterRole
    kubectl apply -f - <<EOF
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
  name: asm:kubernetes-observer
rules:
- apiGroups: [""]
  resources: [ "pods", "namespaces", "nodes", "services", "endpoints", "persistentvolumes", "persistentvolumeclaims"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["replicasets", "deployments", "statefulsets", "daemonsets"]
  verbs: ["get", "list", "watch"]
EOF
    
    # 3. Bind the Role to the ServiceAccount
    kubectl create clusterrolebinding "$${SA_NAME}-binding" \
        --clusterrole=asm:kubernetes-observer \
        --serviceaccount="$${NAMESPACE}":"$${SA_NAME}" --dry-run=client -o yaml | kubectl apply -f -

    # 4. Create the Secret for the non-expiring token (Legacy Method)
    echo "Creating legacy token secret: $${SECRET_NAME}"
    kubectl apply -f - <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: $SECRET_NAME
  namespace: $NAMESPACE
  annotations:
    kubernetes.io/service-account.name: $SA_NAME
type: kubernetes.io/service-account-token
EOF
}