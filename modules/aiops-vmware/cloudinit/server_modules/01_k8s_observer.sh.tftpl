# modules/01_k8s_observer.sh
#
# Contains functions related to ServiceAccount and RBAC configuration.

# Global variables
SA_NAME="asm-k8s-account"
K8S_SECRET_NAME="$${SA_NAME}-legacy-token"
K8S_SA_NAMESPACE="default"

fn_wait_for_secret_token() {
    local max_attempts=15
    local attempt=0
    local token_exists=false
    local wait_interval=2

    echo "Waiting for legacy token Secret ($${K8S_SECRET_NAME}) to be generated..."

    while [ "$attempt" -lt "$max_attempts" ]; do
        # Check if the token data key exists and is non-empty
        if kubectl get secret "$${K8S_SECRET_NAME}" -n "$${K8S_SA_NAMESPACE}" -o jsonpath='{.data.token}' >/dev/null 2>&1; then
            token_exists=true
            break
        fi
        
        echo "Token data not yet available in secret. Retrying in $${wait_interval} seconds... (Attempt $((attempt + 1))/$${max_attempts})"
        sleep "$${wait_interval}"
        attempt=$((attempt + 1))
    done

    if [ "$token_exists" = true ]; then
        echo "Success: Legacy token data is now available."
    else
        echo "Error: Token generation failed after $max_attempts attempts. Check Kubernetes logs." >&2
        return 1
    fi
}

fn_configure_rbac_for_service_account() {
    echo "Applying RBAC for Service Account: $${SA_NAME}"

    # 1. Create the ServiceAccount
    kubectl create serviceaccount "$${SA_NAME}" --namespace "$${K8S_SA_NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -

    # 2. Create the ClusterRole
    kubectl apply -f - <<EOF
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
  name: asm:kubernetes-observer
rules:
- apiGroups: [""]
  resources: [ "pods", "namespaces", "nodes", "services", "endpoints", "persistentvolumes", "persistentvolumeclaims"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["replicasets", "deployments", "statefulsets", "daemonsets"]
  verbs: ["get", "list", "watch"]
EOF
    
    # 3. Bind the Role to the ServiceAccount
    kubectl create clusterrolebinding "$${SA_NAME}-binding" \
        --clusterrole=asm:kubernetes-observer \
        --serviceaccount="$${K8S_SA_NAMESPACE}":"$${SA_NAME}" --dry-run=client -o yaml | kubectl apply -f -

    # 4. Create the Secret for the non-expiring token (Legacy Method)
    echo "Creating legacy token secret: $${K8S_SECRET_NAME}"
    kubectl apply -f - <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: $K8S_SECRET_NAME
  namespace: $K8S_SA_NAMESPACE
  annotations:
    kubernetes.io/service-account.name: $SA_NAME
type: kubernetes.io/service-account-token
EOF
}

fn_load_k8s_observer_job() {
    local API_SERVER="${k3s_url}"
    local API_PORT="6443"
    
    local OBSERVER_SVC_NAME="aiops-topology-kubernetes-observer"
    local SVC_PORT="9108"
    local LOCAL_PORT="9108"
    local TENANT_ID="cfd95b7e-3bc7-4006-a4a8-a73a79c71255"

    echo "Retrieving Observer credentials..."
    
    # 1. Find the AIOps Namespace by looking for the orchestrator pod
    # Using awk '{print$1}' to get the first column (namespace) and head -n 1 for safety
    local AIOPS_NAMESPACE=$(kubectl get po -A | grep aiops-orchestrator-controller | awk '{print$1}' | head -n 1)
    
    if [ -z "$${AIOPS_NAMESPACE}" ]; then
        echo "Error: Could not determine AIOps namespace. Check if aiops-orchestrator-controller is running." >&2
        return 1
    fi
    echo "Found AIOps Namespace: $${AIOPS_NAMESPACE}"
    
    # 2. Retrieve Username and Password from the secret
    local TOPO_REST_USR=$(kubectl get secret aiops-topology-asm-credentials -n "$${AIOPS_NAMESPACE}" -o jsonpath='{.data.username}' | base64 --decode)
    local TOPO_REST_PWD=$(kubectl get secret aiops-topology-asm-credentials -n "$${AIOPS_NAMESPACE}" -o jsonpath='{.data.password}' | base64 --decode)
    
    # Combine for basic auth login
    local LOGIN="$${TOPO_REST_USR}:$${TOPO_REST_PWD}"
    
    # Retrieve the K8s Service Account Token from the Secret
    echo "Retrieving K8s Service Account Token from secret $${K8S_SECRET_NAME}..."
    local API_TOKEN=$(kubectl get secret "$${K8S_SECRET_NAME}" -n "$${K8S_SA_NAMESPACE}" -o jsonpath='{.data.token}' | base64 --decode)
    
    if [ -z "$${API_TOKEN}" ]; then
        echo "Error: K8s Service Account Token is empty. Check secret $${K8S_SECRET_NAME}." >&2
        return 1
    fi

    echo "Setting up port-forward from localhost:$${LOCAL_PORT} to $${OBSERVER_SVC_NAME}:$${SVC_PORT}..."
    
    # Start port-forwarding in the background and bind to all local interfaces
    kubectl port-forward svc/"$${OBSERVER_SVC_NAME}" "$${LOCAL_PORT}":"$${SVC_PORT}" -n "$${AIOPS_NAMESPACE}" > /dev/null 2>&1 &
    local PF_PID=$!
    
    # Ensure the background process is killed when the function exits
    trap "kill $${PF_PID}" EXIT

    echo "Waiting 5 seconds for port-forward tunnel to stabilize..."
    sleep 5
    
    # --- 1. Define the JSON Payload ---
    JSON_PAYLOAD=$(cat <<EOF
{
    "unique_id": "k3s-load",
    "type": "load",
    "description": "Load AIOps on Linux Topology",
    "parameters": {
        "data_center": "IBMCloud",
        "master_ip": "$${API_SERVER}",
        "api_port": "$${API_PORT}",
        "token": {
            "hiddenString": "$${API_TOKEN}",
            "encrypted": false
        },
        "trust_all_certificate": true,
        "hide_terminated_pods": false,
        "connect_read_timeout_ms": 5000,
        "role_token": false,
        "namespaceGroupParameters": {
            "correlate": true
        }
    },
    "schedule": {
        "interval": null,
        "units": null,
        "nextRunTime": null
    },
    "write_file_observer_file": false,
    "scheduleRequest": true
}
EOF
)

    # --- 2. Execute the curl command ---
    echo "Executing API call to load Kubernetes Observer job..."
    
    curl_output=$(curl -s -k \
        -X POST "https://localhost:$${LOCAL_PORT}/1.0/kubernetes-observer/jobs/load" \
        --header "X-TenantID: $${TENANT_ID}" \
        --header 'Accept: application/json' \
        -u "$${LOGIN}" \
        --header 'Content-Type: application/json' \
        -d "$${JSON_PAYLOAD}")

    local curl_exit_code=$?

    # --- 3. Clean up and Report ---
    # The trap EXIT will handle the kill $PF_PID, but we can kill it explicitly here too
    # to allow the trap handler to run cleanly.
    kill $${PF_PID} || true 
    
    if [ "$curl_exit_code" -eq 0 ]; then
        echo "API Call Successful. Response:"
        echo "$${curl_output}" | jq . 2>/dev/null || echo "$${curl_output}"
        return 0
    else
        echo "API Call Failed. Curl Exit Code: $${curl_exit_code}" >&2
        echo "Raw Response: $${curl_output}" >&2
        return 1
    fi
}